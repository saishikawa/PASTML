import os
import pandas as pd
from matplotlib.pyplot import show, savefig, ylim, xscale, xlim
import ete3

# To run locally:
# snakemake --keep-going --cores 4

# To generate a graph
# snakemake --dag | dot -Tpdf > pipeline.pdf

configfile: "config.yaml"
localrules: all

folder = os.path.abspath(config["folder"])
pastml = config['pastml'],

ml_methods = ["marginal_approx", "marginal", "max_posteriori", "joint"]
p_methods = ["downpass", "acctran", "deltran"]
taxa = '1000'
state = '20'
n_trees = 10
reps = 10
tree_type = "ID"
rates = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]


rule all:
    input:
        bs = expand(os.path.join(folder, 'results',
                    'taxa_{taxa}_state_{state}_model_{{model}}_trees_{tree_type}_BS.pdf'
                        .format(taxa=taxa, state=state, tree_type=tree_type)),
                    model=['JC', 'F81', 'HKY'])


rule generate_scenario:
    input:
        trees = expand(os.path.join(folder, 'trees_{{taxa}}_original',
                                    '{{taxa}}.taxa.b.{{rate}}.{n_tree}.tre'), n_tree=range(1, n_trees + 1))
    output:
        annotations = expand(os.path.join(folder, 'Annotations_{{state}}', 'rate{{rate}}',
                            'Annotation.taxa_{{taxa}}.trees_{n_tree}.rep_{rep}.txt'),
                             n_tree=range(1, n_trees + 1), rep=range(1, reps + 1)),
        scenarios = expand(os.path.join(folder, 'scenarios_{{state}}', 'rate{{rate}}',
                                        'simulated_scenario.taxa_{{taxa}}.trees_{n_tree}.rep_{rep}.txt'),
                           n_tree=range(1, n_trees + 1), rep=range(1, reps + 1))
    params:
        mem = 2000,
        name = 'seq-gen',
        taxa = '{taxa}',
        state = '{state}',
        rate = '{rate}'
    run:
        from ete3 import Tree

        def name_tree(tree):
            for i, node in enumerate(tree.traverse()):
                node.name = '{}_{}'.format('tip' if node.is_leaf() else 'node', i)
            return tree

        args = dict(params)
        for n_tree in range(1, n_trees + 1):
            args['n_tree'] = n_tree
            unnamed_tree = os.path.join(folder, 'trees_{taxa}_original'.format(**args), '{taxa}.taxa.b.{rate}.{n_tree}.tre'.format(**args))
            tree = os.path.join(folder, 'trees_{taxa}_original'.format(**args), '{taxa}.taxa.b.{rate}.{n_tree}.named.tre'.format(**args))
            name_tree(Tree(unnamed_tree)).write(outfile=tree, format=3)

            for rep in range(1, reps + 1):
                args['rep'] = rep
                annotation = os.path.join(folder, 'Annotations_{state}'.format(**args), 'rate{rate}'.format(**args),
                                         'Annotation.taxa_{taxa}.trees_{n_tree}.rep_{rep}.txt'.format(**args))
                scenario = os.path.join(folder, 'scenarios_{state}'.format(**args), 'rate{rate}'.format(**args),
                                         'simulated_scenario.taxa_{taxa}.trees_{n_tree}.rep_{rep}.txt'.format(**args))
                if (int(state) == 4):
                    shell("seq-gen -mHKY -l1 -wa -q -f0.2,0.4,0.3,0.1 -t8.0 < {tree} > {tree}.seq-gen.txt")
                else:
                    shell("seq-gen -mJTT -l1 -wa -q < {tree} > {tree}.seq-gen.txt")
                shell("""
                    grep "^node_" {tree}.seq-gen.txt > {scenario}
                    grep "^tip_" {tree}.seq-gen.txt > {annotation}
                    rm {tree}.seq-gen.txt
                """)

rule plot:
    input:
        bs_ml = expand(os.path.join(folder, 'results', 'taxa_{{taxa}}', 'state_{{state}}', 'model_{{model}}',
                                    'trees_{{tree_type}}', 'prediction_{prediction_method}', 'BS.txt'),
                       prediction_method=ml_methods),
        bs_p = expand(os.path.join(folder, 'results', 'taxa_{{taxa}}', 'state_{{state}}', 'model_parsimony',
                                   'trees_{{tree_type}}', 'prediction_{prediction_method}', 'BS.txt'),
                      prediction_method=p_methods)
    output:
        fig = os.path.join(folder, 'results', 'taxa_{taxa}_state_{state}_model_{model}_trees_{tree_type}_BS.pdf')
    run:
        df = pd.read_csv(input.bs[0], header=0, index_col=0)
        for _ in input.bs_ml[1:] + input.bs_p:
            df = df.join(pd.read_csv(_, header=0, index_col=0))
        df.plot(marker='.')
        ylim(ymin=0)
        xlim(xmin=min(rates))
        xscale('log')
        savefig(output.fig)


rule combine_bs:
    input:
        bs = expand(os.path.join(folder, 'results', 'rate_{rate}', 'taxa_{{taxa}}', 'state_{{state}}', 'model_{{model}}',
            'trees_{{tree_type}}', 'prediction_{{prediction_method}}', 'BS.txt'), rate=rates),
        np = expand(os.path.join(folder, 'results', 'rate_{rate}', 'taxa_{{taxa}}', 'state_{{state}}', 'model_{{model}}',
            'trees_{{tree_type}}', 'prediction_{{prediction_method}}', 'NP.txt'), rate=rates),
        sf = expand(os.path.join(folder, 'results', 'rate_{rate}', 'taxa_{{taxa}}', 'state_{{state}}', 'model_{{model}}',
            'trees_{{tree_type}}', 'prediction_{{prediction_method}}', 'SF.txt'), rate=rates),
    output:
        bs = os.path.join(folder, 'results', 'taxa_{taxa}', 'state_{state}', 'model_{model}', 'trees_{tree_type}',
            'prediction_{prediction_method}', 'BS.txt'),
        np = os.path.join(folder, 'results', 'taxa_{taxa}', 'state_{state}', 'model_{model}', 'trees_{tree_type}',
            'prediction_{prediction_method}', 'NP.txt'),
        sf = os.path.join(folder, 'results', 'taxa_{taxa}', 'state_{state}', 'model_{model}', 'trees_{tree_type}',
            'prediction_{prediction_method}', 'SF.txt'),
    params:
        mem = 2000,
        name = 'BS',
        taxa = '{taxa}',
        state = '{state}',
        tree_type = "{tree_type}",
        model = "{model}",
        prediction_method = "{prediction_method}",
    run:
        bs_df = pd.DataFrame(index=rates, columns=[params.prediction_method])
        sf_df = pd.DataFrame(index=rates, columns=[params.prediction_method])
        np_df = pd.DataFrame(index=rates, columns=[params.prediction_method])

        bs_df.fillna(0.0, inplace=True)
        np_df.fillna(0.0, inplace=True)
        sf_df.fillna(0.0, inplace=True)

        for rate in rates:
            path = os.path.join(folder, 'results', 'rate_{rate}'.format(rate=rate), 'taxa_{taxa}'.format(**params),
                                'state_{state}'.format(**params),
                                'model_{model}'.format(**params), 'trees_{tree_type}'.format(**params),
                                'prediction_{prediction_method}'.format(**params))

            bs_df.loc[rate, params.prediction_method] = float(pd.read_csv(os.path.join(path, 'BS.txt'), header=0, index_col=0).mean())
            np_df.loc[rate, params.prediction_method] = float(pd.read_csv(os.path.join(path, 'NP.txt'), header=0, index_col=0).mean())
            sf_df.loc[rate, params.prediction_method] = float(pd.read_csv(os.path.join(path, 'SF.txt'), header=0, index_col=0).mean())

        bs_df.to_csv(output.bs)
        np_df.to_csv(output.np)
        sf_df.to_csv(output.sf)


rule get_brier_scores:
    '''
    Calculates BS.
    '''
    input:
        trees = expand(os.path.join(folder, 'trees_{{taxa}}_{{tree_type}}',
                                    '{{taxa}}.taxa.b.{{rate}}.{n_tree}.{{tree_type}}.tre'),
                       n_tree=range(1, n_trees + 1)),
        annotations = expand(os.path.join(folder, 'Annotations_{{state}}', 'rate{{rate}}',
                                          'Annotation.taxa_{{taxa}}.trees_{n_tree}.rep_{rep}.txt'),
                             n_tree=range(1, n_trees + 1), rep=range(1, reps + 1)),
        scenarios = expand(os.path.join(folder, 'scenarios_{{state}}', 'rate{{rate}}',
                                        'simulated_scenario.taxa_{{taxa}}.trees_{n_tree}.rep_{rep}.txt'),
                           n_tree=range(1, n_trees + 1), rep=range(1, reps + 1))
    output:
        bs = os.path.join(folder, 'results', 'rate_{rate}', 'taxa_{taxa}', 'state_{state}', 'model_{model}', 'trees_{tree_type}',
            'prediction_{prediction_method}', 'BS.txt'),
        np = os.path.join(folder, 'results', 'rate_{rate}', 'taxa_{taxa}', 'state_{state}', 'model_{model}', 'trees_{tree_type}',
            'prediction_{prediction_method}', 'NP.txt'),
        sf = os.path.join(folder, 'results', 'rate_{rate}', 'taxa_{taxa}', 'state_{state}', 'model_{model}', 'trees_{tree_type}',
            'prediction_{prediction_method}', 'SF.txt'),
    params:
        mem = 2000,
        name = 'BS',
        taxa = '{taxa}',
        state = '{state}',
        tree_type = "{tree_type}",
        model = "{model}",
        prediction_method = "{prediction_method}",
        rate = '{rate}'
    threads: 1
    run:
        args = dict(params)

        brier_reps_df = pd.DataFrame(index=range(1, n_trees + 1), columns=[params.prediction_method])
        scaling_factor_df = pd.DataFrame(index=range(1, n_trees + 1), columns=[params.prediction_method])
        num_predictions_df = pd.DataFrame(index=range(1, n_trees + 1), columns=[params.prediction_method])

        brier_reps_df.fillna(0.0, inplace=True)
        num_predictions_df.fillna(0.0, inplace=True)
        scaling_factor_df.fillna(0.0, inplace=True)

        for n_tree in range(1, n_trees + 1):
            args['n_tree'] = n_tree
            tree = os.path.join(folder, 'trees_{taxa}_{tree_type}'.format(**args),
                                         '{taxa}.taxa.b.{rate}.{n_tree}.{tree_type}.tre'
                                         .format(**args))
            for rep in range(reps):
                args['rep'] = rep + 1

                annotations = os.path.join(folder, 'Annotations_{state}'.format(**args), 'rate{rate}'.format(**args),
                                         'Annotation.taxa_{taxa}.trees_{n_tree}.rep_{rep}.txt'.format(**args))
                true_scenario = os.path.join(folder, 'scenarios_{state}'.format(**args), 'rate{rate}'.format(**args),
                                         'simulated_scenario.taxa_{taxa}.trees_{n_tree}.rep_{rep}.txt'.format(**args))

                out_annotations = os.path.join(folder, 'Annotations_{state}'.format(**args), 'rate{rate}'.format(**args),
                                             'Out.annotations.{taxa}.{state}.{rate}.{n_tree}.{rep}.{model}.{prediction_method}.txt'
                                             .format(**args))
                out_params = os.path.join(folder, 'Annotations_{state}'.format(**args), 'rate{rate}'.format(**args),
                                             'Out.params.{taxa}.{state}.{rate}.{n_tree}.{rep}.{model}.{prediction_method}.txt'
                                             .format(**args))
                out_tree = os.path.join(folder, 'Annotations_{state}'.format(**args), 'rate{rate}'.format(**args),
                                             'Out.tree.{taxa}.{state}.{rate}.{n_tree}.{rep}.{model}.{prediction_method}.nwk'
                                             .format(**args))
                shell("""
                {pastml} -a {annotations} -t {tree} -m {params.model} -p {params.prediction_method} -o {out_annotations} -r {out_params} -n {out_tree} -q
                rm {out_tree}
                """)

                true_df = pd.read_csv(true_scenario, header=None, index_col=0, names=['id', 'True_state'])
                for _ in true_df['True_state'].unique():
                    true_df[_] = (true_df['True_state'] == _).astype(int)
                true_df.drop(labels=['True_state'], axis=1, inplace=True)

                if params.prediction_method not in p_methods:
                    scaling_factor_df.loc[n_tree, params.prediction_method] += float(pd.read_csv(out_params, header=None, index_col=0).loc['scaling factor', 1])
                    os.remove(out_params)

                state_col = '{prediction_method}_state'.format(**args)
                df = pd.read_csv(out_annotations, header=0, index_col=0)
                df = df[df.index.isin(true_df.index)]
                bs = (df - true_df).pow(2).mean(axis=1).mean()
                brier_reps_df.loc[n_tree, params.prediction_method] += bs
                num_predictions_df.loc[n_tree, params.prediction_method] += (df > 0).astype(int).sum(axis=1).mean()

                os.remove(out_annotations)

        brier_reps_df /= reps
        num_predictions_df /= reps
        scaling_factor_df /= reps

        brier_reps_df.to_csv(output.bs)
        num_predictions_df.to_csv(output.np)
        scaling_factor_df.to_csv(output.sf)

